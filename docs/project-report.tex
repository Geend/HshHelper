% arara: pdflatex: { shell: true, draft: true }
% arara: makeglossaries
% arara: biber
% arara: pdflatex: { shell: true, synctex: true }
% arara: pdflatex: { shell: true, synctex: true }

\documentclass[12pt,DIV14,BCOR10mm,a4paper,parskip=half-,headsepline,headinclude,english,ngerman,bibliography=totocnumbered]{scrreprt}

\usepackage{hshhelper_base}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{document}    % hier gehts los
  \thispagestyle{empty} % Titelseite
\includegraphics[width=0.2\textwidth]{Wortmarke_WI_schwarz}

   {  ~ \sffamily
  \vfill
  {\Huge\bfseries Projekt-Erfahrungsbericht}
  \bigskip

  {\Large
  Dennis Grabowski, Julius Zint, Philip Matesanz, Torben Voltmer \\[2ex]
  Masterprojekt \enquote{Entwicklung und Analyse einer sicheren \\Web-Anwendung} \\
  Wintersemester 18/19
 \\[5ex]
   \today }
}
 \vfill

  ~ \hfill
  \includegraphics[height=0.3\paperheight]{H_WI_Pantone1665}

\vspace*{-3cm}

\tableofcontents  % Inhaltsverzeichnis

\chapter{Projektorganisation}


\section{Welche Methoden haben gut oder schlecht funktioniert, und warum?}

\paragraph{Reviews}
Git hat einen sehr mächtigen Branching Mechanismus durch welchen es in Kombination mit Github sehr einfach möglich ist Pull Requests zu erstellen. Hätte man im Team festgelegt das nur über Pull Requests auf den Master gemerged wird, hätte man Code Reviews für jedes Changeset erzwingen können. Da solch ein Vorgehen allerdings auch einiges an Zeit in Anspruch nimmt kann nicht mit Sicherheit gesagt werden, ob dies zu einem besseren Endergebnis geführt hätte.

\paragraph{Continuous Integration}
Wir haben uns bemüht die Quellcodeänderungen der einzelnen Projektteilnehmer möglichst häufig zusammenzuführen. Ein Werkzeug (in Form eines CI-Servers) wurde dabei allerdings nicht verwendet. Es wurde leider öfter vergessen die zahlreichen Unit-Test vor dem Einchecken von Codeänderung auszuführen, was dazu führte dass Fehler erst später auffielen.
In Verbindung mit dem vorher erwähnten, aber aus Zeitgründen nicht immer durchgeführten Branching-Mechanismus und einem CI-Server wie Jenkins oder CircleCI hätte man ferner erzwingen können, dass Branches nur gemergt werden können, wenn der Branch/der Pull Request nicht nur erfolgreich baut, sondern auch alle Tests erfolgreich durchlaufen.

\paragraph{Prototyping}
Um ein Gefühl für Play und die Anforderungen an die Anwendung zu bekommen, haben wir für viele Funktionen zunächst einen möglichst einfachen Prototypen geschrieben. Die Prototypen wurden daraufhin meist iterative verbessert, bis sie die Anforderungen vollständig erfüllt haben. Gelegentlich wurden Protoypen aber auch komplett verworfen und die Funktionalität erneut implementiert. So war es möglich auf


\paragraph{Pair Programming} Im Team wurden mehrmals zweier Gruppen gebildet um Aufgaben zu bewältigen. In diesen Zweierteams wurden dann häufig Pairprogramming praktiziert. Dies hat sich speziell in diesem Projekt hervorragend anwenden lassen, da durch die Vorträge, die am Projekt Anfang gehalten wurden, jeder einen unterschiedlichen Einblick in das Play Framework erhalten hat und somit sein Fachwissen beim Pairprogramming einbringen konnte.


\paragraph{Pentesting} Das Penetration Testing unserer Anwendung hat einen Großteil zur Stabilität und Sicherheit der Anwendung beigetragen. Abgesehen von den gefundenen Sicherheitsschwachstellen und funktionalen Fehlern der Anwendung wurde man so schon bevor man die Anwendung des Gegnerteams untersucht mit Werkzeugen wie dem ZAP-Webproxy oder einfacheren Kommandozeilen Werkzeugen wie Curl vertraut.

\paragraph{Static Analysis} Die Static Code Analysis der Entwicklungsumgebung IntelliJ wurde auf das Projekt angewendet, da dies mit nur sehr geringem Aufwand möglich ist. Mit ihr wurde eine ein Anwendungsfehler entdeckt bei dem eine Überprüfung auf \texttt{NULL} fehlte. Das Finden dieses Fehlers langt schon völlig aus um den geringen Aufwand zu rechtfertigen. Static Analysis würde das Team somit bei einem weiteren Projekt wieder durchführen.

\paragraph{Unit Tests} Unit Tests verbesserten in unserem Fall nicht nur die Wartbarkeit der Software sondern waren in diesem Projekt auch maßgeblich an der Verbesserung der Software-Architektur beteiligt. Viele statische Methoden wurde so sinnvoll in Objekten zusammengefasst und via Dependency Injection in der Anwendung verteilt. Sicherheitsaspekte wurde natürlich auch durch Unittests überprüft und somit sind diese unverzichtbar für eine gute Software. Insgesamt wurde hierdurch unser Vertrauen zu unserer Applikation stark angehoben.

\paragraph{Intensive Diskussionen} Von Beginn bis hin zum Abschluss des Projekts wurden durchwegs intensive Diskussionen geführt. Diese waren stets sehr produktiv, da jedes Teammitglied unterschiedliche Erfahrungen mit einbrachte und in den meisten Fällen gab es immer jemanden der die Rolle des Diskussionsleiters übernommen hat und dafür sorgte, dass keine unsachlichen Bemerkungen einfließen oder zu weit vom Thema abschweift wird. Diskutiert wurde selbstverständlich über alle Themengebiete wie beispielsweise: Architektur, Sicherheit, Patterns und viele mehr.

\section{Wie hoch war der Aufwand für die jeweiligen Aktivitäten?}
Bei der Nachbesprechung wurde erwähnt das dieses Team aufgrund der großen Anzahl an Zusatzfeatures keinerlei Aussagen über den Zeitaufwand treffen sollte. Tatsächlich ist es aber so das Zusatzfeatures wie die Zwei-Faktor Authentifizierung oder Informationsübersichtseiten nur einen eher kleinen Teil der Entwicklungszeit in Anspruch genommen haben. Das Design der Oberfläche ist das einzige Zusatzfeature was tatsächlich einen hohen Zeitaufwand hatte welcher möglicherweise nicht gerechtfertigt ist. Alle anderen Zusatzfeatures waren entweder schnell zu implementieren oder dienen direkt der Sicherheit unserer Anwendung was ja das allgemeine Ziel dieses Projekts ist. Folgende Auflistung zeigt prozentuale Schätzwerte für den Zeitaufwand:

\begin{itemize}
  \item 30\% Programmierung
  \item 30\% Testen der Anwendung
  \item 20\% Organisatorisches (Diskussionen, Ideen)
  \item 20\% Anfertigen der geforderten Dokumente
\end{itemize}

Von den Dokumenten hat die Bedrohungsanalyse am meisten Zeit in Anspruch genommen. Das Entdecken der Bedrohungen und speziell das Ausformulieren dieser empfanden wir als besonders aufwändig. Dies wird vom Team aber als sehr hilfreich und positiv bewertet, da dieses Dokument immens zur Sicherheit der Anwendung beigetragen hat.

Abschließend ist zu sagen, dass der Zeitaufwand für dieses Projekt als sehr hoch eingestuft wird.
Das Entwickeln eines eigenen Produkts ist für das kurze Wintersemester schon anspruchsvoll und dann kommt hinzu noch eine vollständige Analyse der Anwendung des gegnerischen Teams.
Gerade in Kombination mit den anzufertigen Dokumenten bildet sich hier ein großes Arbeitsaufwand.

\section{Welche Fehler wurden gemacht und woran erkannt?}

\begin{itemize}
  \item Insgesamt betrachten wir die Integration und den darauffolgenden Ausbau von Bootstrap als starke Zeitverschwendung. Wir hatten uns zu wenig Gedanken darüber gemacht, in welcher Form wir unsere Applikation präsentieren wollen und hatten im Zuge dessen versucht, eine Art \enquote{Minibibliothek} zu schreiben, mit der wir relativ schnell Elemente zur Seite hinzufügen können, die den Bootstrap-Stil einheitlich appliziert, ohne stetig die Bootstrap-CSS-Klassen wieder angeben zu müssen. Dort hätten wir früher einen Schlussstrich ziehen müssen, um weitere Zeitverschwendung zu unterbinden.
  \item Wir hatten zunächst manche Variablen statisch unseren Klassen hinzugefügt, weil es konzeptionell sinnig erschien. Jedoch ist uns beim Implementieren unserer Unittests aufgefallen, dass die Klassen einfacher zu testen sind, wenn man Dependency Injection konsistent verwendet.
  \item Anfänglich war unsere Geschäftslogik nicht von der View-Verarbeitung getrennt. Die gesamte Logik lag innerhalb den Controllern, wodurch das Schreiben der Tests ebenfalls erschwert wurde da nun jeder Test über die HTTP-Schnittstelle erfolgen musste. Daraufhin haben wir die Manager eingeführt, die die Geschäftslogik übernommen haben, wodurch es wieder möglich war, Unittests für diese zu schrieben. Die View, die Dialogkontrolle sowie alles spezifische zur HTTP/HTML-Domäne verblieb in den Controllern.
\end{itemize}

\section{Wie beurteilen Sie Ihre Projektorganisation bzw. den von Ihnen gewählten Entwicklungsprozess?}

Bei unserem Projekt-Kickoff-Meeting hatten wir beschlossen, nach einem agilen jedoch nicht genauer beschriebenen oder existierenden Entwicklungsprozess vorzugehen. Wir haben diesen an Scrum angelegt, machten uns aber zusätzlich einige Ideen von Extreme Programming wie das \enquote{Test-Driven-Development} oder \enquote{Pair-Programming} zu eigen.
Zu Beginn jeder Iteration hatten wir bei einer Art \enquote{Sprint Planning} gemeinsam besprochen, welche Aufgaben zu erledigen sind und welchen Hürden wir dabei begegnen könnten. Zusätzlich wurden bei diesen Treffen grundlegende Arbeiten als Team bewältigt, die gegebenfalls alle weiteren Arbeiten beeinflussen könnten, wie zum Beispiel das Datenmodell.
Bei diesen Treffen war es jedem Teammitglied möglich, seine eigenen Ideen und Einwände zur Diskussion freizugeben, wodurch kein bisher nicht besprochener oder bedachter Aspekt ausser Sicht gelassen wurde. So konnte das Team von unterschiedlichen Qualitäten, die von den einzelnen Teammitglieder eingebracht wurden, profitieren.

Da wir als zentralen Git-Server GitHub nutzten, hatten wir auch eine gute Plattform, um unser agiles Projektmanagement abzubilden.
Mithilfe von sogenannten \enquote{Issues} ist es dort möglich, Arbeitspakete abzubilden.
Jedes Issue hat einen Titel, eine Beschreibung, Labels, die zur Kategorisierung dienen, und konnte ferner zu einer Iteration und einem Teammitglied zugeordnet werden.
Ebenfalls ist es möglich, einem Issue weitere Kommentare anzuhängen, so dass auch Diskussionen zu einem spezifischen Arbeitspaket/Problem geführt werden konnten.
Darüber hinaus bietet GitHub ein Kanbanboard, welches wir intensiv genutzt haben.
Auf diesem können Issues oder kleinere Notizen zu vorgefertigten oder selbst erstellten Kategorien zugewiesen werden, um dem Team Überblick darüber zu verschaffen, welche Issues bereits in Bearbeitung sind, welche noch nicht bearbeitet werden und noch keinen zugeordneten Entwickler haben sowie welche bereits abgearbeitet wurden, aber eventuell noch einem Review unterzogen werden sollten.
Zusätzlich ist es möglich, den Status eines Issues (Open/Closed) aber auch seine Zuweisung zu einer Kategorie auf dem Kanbanboard via Commit-Nachrichten zu steuern, wodurch der eigentliche organisatorische Aufwand immens sinkt.

Insgesamt war uns dadurch ein sehr agiler und liberaler Entwicklungsprozess möglich.
Teammitglieder konnten sich eigenständig neue Arbeit aus den Issues oder dem Kanbanboard zuweisen und direkt mit der Bearbeitung des jeweiligen Arbeitspakets beginnen. Das ähnelt bewusst dem \enquote{Pull}-Konzept aus Kanban: So war es uns möglich, die Menge an zeitgleich geöffneten \enquote{Baustellen} gering zu halten und zu garantieren, dass wir keine einzelnen Teammitglieder überlasten, da jeder frei entscheiden konnte, wie viel Zeit er gerade investieren möchte/kann.
Arbeitspakete wurden dementsprechend fein granular definiert, so dass nicht wenige bis keine Abhängigkeiten zueinander bestanden, damit die \enquote{Suche nach neuer Arbeit} ohne größeren Aufwand geschehen konnte.
Durch die Verknüpfung des GitHub-Kontos mit einer E-Mail-Adresse wurden auch die anderen Teammitglieder automatisch von diesen Statusänderungen an den Issues benachrichtigt.
Insgesamt konnte so garantiert werden, dass keine Arbeit doppelt gemacht wird.

Zusammenfassend sind wir sehr zufrieden mit unserer gewählten Projektorganisation und würden ein anderes Projekt wahrscheinlich ähnlich umsetzen.

Kritisch zu betrachten ist jedoch die Menge an Selbstdisziplin, die jedes Teammitglied bei so einem Entwicklungsprozess mit sich bringen muss.
Es ist erfahrungsgemäß schwer, Überblick und Klarheit hier zu behalten, wenn nicht jedes Teammitglied auf eine sorgfältige Pflege der Issues und des Kanbanboards achten.
Dies ist uns beispielsweise daran aufgefallen, dass wir es schwer fanden, die Ergebnisse aller gruppeninternen Diskussionen, Absprachen mit Herrn Prof. Dr. Peine oder andere Erkenntnisse in den jeweiligen Issues zu persistieren.
Positiv zu betrachten ist jedoch das zentrale Handling in GitHub. Hätten wir beispielsweise ein anderes Werkzeug zur Projektorganisation verwendet, welches nicht so eng mit dem Git-Repository verzahnt ist, hätten wir hiermit wohl sogar größere Probleme gehabt; möglicherweise wäre das Organisatorische an dieser Stelle komplett zusammengebrochen.

\section{Wie haben Sie die Projektstruktur erlebt, die Anwendung durch zwei Gruppen mit Rollentausch entwickeln zu lassen?}

\begin{itemize}
  \item Wir betrachten den Wettkampfaspekt eher positiv: Keine Informationen zu teilen hat das Projekt spannender gemacht, da man daraufhin keine Bewertung machen konnte, wie gut man selbst ist, oder die andere Gruppe ist, bzw. welche Ideen sie implementieren.
  \item Paranoia hat's eigentlich interessant gemacht: Wir dachten oftmals, dass die andere Gruppe bessere Ideen hatte, bspw. Benutzerkonzept in der Datenbank
\end{itemize}

\chapter{Verbesserungsvorschläge für zukünftige Projekte}

Welche Verbesserungsvorschläge für zukünftige Projekte haben Sie?

\begin{itemize}
  \item Raeumlichkeiten (TODO Raumnummer unten) eher kritisch gewesen. Vorlesungskulisse war eher unangenehm, da sie stark hoerbar war. Securitylabor auch eher unangenehm wegen Hitze/Geraeuschekulisse wegen der Hardware.
  \item Evtl Aufteilung durch SSE-Note doch nicht sinnvoll - eher Aufteilung nach Erfahrung?
  \item Es ist grundsätzlich unbefriedigend, ein Projekt \enquote{für die Mülltonne} zu produzieren. Die Hochschule hatte offensichtlich Bedarf an einer Anwendung zum Dateiaustausch\footnote{vgl. \url{https://www.gwdg.de/web/guest/about-us/press-releases/2018/press-release-2-2018}}. Man hätte die Anforderungen eventuell an tatsächlichen Bedürfnissen ausrichten können, um langfristig ein eigenes \enquote{hausinternes} Produkt hierfür bereitstellen zu können. Auch wenn eventuell im Rahmen eines Masterprojekts dieses Produkt nicht vollumfänglich fertiggestellt werden könnte, wäre dies über mehrere inkrementelle Projekte möglich ein solches Produkt zu erstellen.
  \item Ein paar schon im Gespraech genannt: Anderes Framework, evtl kein Single Sign-On, evtl Ende-zu-Ende verschuesselter Chat
\end{itemize}

\printbibliography

% Can be used to add a list of acronyms with their description
%\glsaddall
%\deftranslation{to=German}{Acronyms}{Abkürzungsverzeichnis}
%\deftranslation{to=German}{Glossary}{Glossar}
\printacronyms[title=Abkürzungsverzeichnis,toctitle=Abkürzungsverzeichnis]
\printglossary[title=Glossar,toctitle=Glossar,type=main]

%\addcontentsline{toc}{chapter}{\listfigurename}
% Insert list of figures, if a figure has been added to document
\iftotalfigures
  \listoffigures
\fi

%s\addcontentsline{toc}{chapter}{\listtablename}
% \listoftables       % Tabellenverzeichnis

\begin{appendices}

\end{appendices}

\end{document}
