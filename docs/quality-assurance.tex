\documentclass[12pt,DIV14,BCOR10mm,a4paper,twoside,parskip=half-,headsepline,headinclude,english,ngerman,bibliography=totocnumbered]{scrreprt}

\usepackage{hshhelper_base}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{document}    % hier gehts los
  \thispagestyle{empty} % Titelseite
\includegraphics[width=0.2\textwidth]{Wortmarke_WI_schwarz}

   {  ~ \sffamily
  \vfill
  {\Huge\bfseries Bericht: Maßnahmen zur Qualitätssicherung}
  \bigskip

  {\Large
  Dennis Grabowski, Julius Zint, Philip Matesanz, Torben Voltmer \\[2ex]
  Masterprojekt \enquote{Entwicklung und Analyse einer sicheren Web-Anwendung} \\
  Wintersemester 18/19
 \\[5ex]
   \today }
}
 \vfill

  ~ \hfill
  \includegraphics[height=0.3\paperheight]{H_WI_Pantone1665}

\vspace*{-3cm}

\tableofcontents  % Inhaltsverzeichnis

\chapter{Benutzte Methoden}
\section{Vier-Augen-Prinzip}
\section{Tests}

Dadurch, dass wir das Play Framework vor dem Projekt nicht kannten, sowie dass wir einen agilen Entwicklungsprozess nutzen wollten, haben wir abgestimmt, möglichst viel Code durch Tests abzudecken.
Dadurch wird das ein eventuelles Refactoring einfacher, aber auch verstärkt es unser Vertrauen in unsere Software.
Im Anbetracht dessen, dass Änderungen an der Architektur beziehungsweise Implementation durch eine Bedrohungsanalyse respektive gefundene Sicherheitslücken ausgelöst werden können, und wir iterativ Funktionalität zu unserem System hinzufügen wollen, sind \textbf{automatisierbare} Tests unabdingbar.
Um dieses Ziel für unsere funktionalen, aber auch nicht-funktionalen Anforderungen zu erreichen, benutzen wir die von Play mitgelieferte JUnit-Bibliothek.

\subsection{Funktionale Tests}

Zur Verifikation der funktionalen Korrektheit unseres System nutzen wir Unit-, seltener Integrations aber auch Systemtests.
Hierbei haben wir darauf geachtet, dass es uns durch \enquote{Dependency Injection} möglich ist, die Abhängigkeiten einer Klasse durch \enquote{Mocks} zu ersetzen.
Dadurch wird garantiert, dass lediglich das Verhalten einer Klasse getestet wird, und dass dieses Verhalten nur auf dem durchs Interface vorgeschriebene Verhalten seiner Abhängigkeiten basiert.

\externaldocument[Arch1-]{architecture}
Für die in dem Klassendiagramm (siehe Architekturbeschreibung \ref{Arch1-architecture:class_diagram}) aufgezeigten \enquote{Pakete} werden folgende Voraussetzungen sowie Nachbedingungen getestet:

\begin{enumerate}
  \item Controller
  \begin{itemize}
    \item Routen werden durch die richtigen internen Methoden abgebildet,
    \item Nutzer muss authentisiert sein, um Route anzusurfen,
    \item Login-Page kann ausschliesslich ohne valide Session aufgerufen werden,
    \item Methoden geben erwarteteten HTTP Status Code zurück.
  \end{itemize}

  \item Manager
  \begin{itemize}
    \item
  \end{itemize}

  \item Domänenlogik
  \begin{itemize}
    \item Nach 5 fehlgeschlagenen Logins muss ein Nutzer ein reCAPTCHA lösen,
    \item Nach 50 fehlgeschlagenen Logins von einer IP-Adresse muss ein reCAPTCHA gelöst werden,
    \item Nach 100 fehlgeschlagenen Logins ist eine IP-Adresse ausgesperrt
  \end{itemize}

  \item Database
  \begin{itemize}
    \item Von h2 angepriesene \texttt{ALLOW\_LITERALS}-Konfiguration funktioniert wie erwartet
  \end{itemize}

  \item Cross Cutting Concerns
  \begin{itemize}
    \item Maximale Passwortlänge ist auf das von BCrypt vorgegebene Limit gesetzt
  \end{itemize}
\end{enumerate}

% TODO: Which classes are tested - What contracts are tested
% Do not forget to write down "easier" tests, e.g. the h2 ALLOW_LITERALS
% test to verify our understanding of said option
% Classcoverage, Branchcoverage, Linecoverage, Methodcoverage
% End-to-End? Unittests? Wird DB getestet?

Bei den View-spezifischen \enquote{Data Transfer Object}-Klassen sehen wir keinen Bedarf zum Testen.
Sie sind essentiell nur \enquote{Plain Old Data}-Objekte, die ausser trivialen Zugriffsmethoden (Getter und Setter) keine weitere Methoden besitzen.
Dies gilt für alle trivialen Zugriffsmethoden unserer Klassen.
Darüber hinaus gibt es keine direkten Tests, die verifizieren, ob eine simple Relation von EBean sachgerecht auf das richtige Objekt abgebildet wird.
% TODO, Iteration 2: Files too
Eine Ausnahme bilden hier die \texttt{User}-Entitäten, da beim Löschen eines Benutzers ebenfalls alle Gruppen gelöscht werden müssen, dessen Besitzer er ist. Für so eine kaskadierende Löschoperation wurde extra ein Test geschrieben.

% Which faults have been found through this testing?
% E.g. NullPointerExceptions in form validations
% Cascading delete user.ownerOf -> grps
% Literals used in SQL
% Captcha does not work in Firefox
% View errors as our bootstrap helper did not set values from .fill()-method
% Verification that controllers do return correct HTTP status codes in differing situations on the endpoints
% E-Mail addresses were not unique, allowing a malicious user to get a PW if he had registried an account with the same email as another user
% Validation for javascript/html in form fields

\textcolor{red}{
Vielleicht nicht unbedingt erwähnen, wie viel Coverage wir wirklich haben?
Idee: Coverage Report im Anhang packen, Zahlen grob anreißen. Alles andere zu genau.
}

\subsection{Tests zur Prüfung von sicherheitsrelevanten Funktionen}

Sessionmanagement?
Ist unser Cookie sicher und wirklich zufällig?
Brute-force Schutz (Stichwort: "Firewall")
Authorization? Können Endpoints nur von den richtigen Privilegien angesurft werden?
Wird CSRF richtig genutzt?
Salted bcrypt richtig? Nutzen wir ausreichend Iterationen oder können wir mit einem Test das irgendwie knacken?
Kommt das Captcha zur richtigen Zeit? Ist das Captcha austricksbar?
Haben wir Quality rules für passwörter?
Können wir kaputte Daten in die Forms eintragen?
Können wir irgendwelche Requests forgen?
Können SQL-Injections ausgeführt werden?
Setzen wir alle richtigen Security-Header?

\subsection{Penetrationstests}
Um die Funktionalität der CSRF-Tokens sicherzustellen, wurde ein Penetrationstest durchgeführt. Im ersten Schritt wurde dazu einfach das CSRF-Token aus dem HTML der Form gelöscht. Diese Anfrage wird wie erwartet vom Server mit einer von Play vorgefertigten \enquote{\texttt{Unautorized}} Seite beantwortet. In einem weiteren Schritt wurde mit Curl ein Anfrage erstellt in welcher lediglich der Benutzername und Passwort aber kein CSRF-Token enthalten war. Diese Anfrage wurde vom Server ohne Beanstandung akzeptiert. Der Grund hierfür ist, dass das CSRF-Token weder im Cookie noch als Form-Daten an den Server übermittelt wird. Auch die \texttt{RequireCSRFCheck} Annotation schafft hierfür keine Abhilfe. CSRF Möglichkeit und somit eine Sicherheitslücke liegt vor, wenn folgende Bedingungen gelten:

  \begin{itemize}
    \item Das Play-Session-Cookie wird nicht für die Session-Implementierung der Anwendung verwendet.
    \item Das Play-Session-Cookie ist nicht vorhanden ist.
  \end{itemize}

Lockt man ein Opfer auf eine Seite mit einer Form kann durch einen Klick beispielsweise ein Nutzer aus einer Gruppe gelöscht werden indem bei der Anfrage das CSRF-Token einfach weggelassen wird.

Ein konkretes Angriffsszenario in dieser Anwendung wäre der Login. Das Opfer muss dazu keinerlei Cookies von der HsH-Helper Seite im Browser haben. Dies kann gegeben sein wenn es seine Cookies gelöscht hat oder den Incognito Modus im Browser verwendet. Ein Angreifer kann nun das Opfer auf eine von ihm präparierte Seite locken, wo durch das Klicken auf einen Link eine Login Form abgeschickt wird. Somit ist das Opfer angemeldet unter einem Benutzeraccount, welcher auch dem Angreifer bekannt ist. Ist das Opfer nun unvorsichtig und verifiziert den aktuellen Benutzeraccount nicht, lädt es Dateien möglicherweise Dateien hoch unter einem Benutzeraccount auf welchen der Angreifer zugriff hat.

%Welche Penetrationstests wurden durchgeführt?
%Gibt es ggf. automatisierbare Skripts?
%Wenn ja, für welche Angriffe?

\section{Reviews}
\subsection{Session Konzept}
Die erste Version unseres Session Konzepts wurde einem Review unterzogen. Das Review wurde von einer Person durchgeführt und benötigte 2 Stunden. Hierbei wurde insb. ein schlechtes Design bemängelt. Die Session-Funktionalität wurde nicht von einer bzw. wenigen Klassen abgebildet, sondern auf verschiedenste Klassen verteilt: Die Login-Methode im Controller erstellte inline einen Datenbank-Eintrag sowie ein Cookie. Andere Controller-Methoden manipulierten inline die entsprechenden Einträge und entfernten nach Bedarf Cookies. Das Wissen darüber, was überhaupt eine Session darstellt war so nicht an einer zentralen Stelle im Code zu finden und entsprechend schwer zu prüfen.

Ebenfalls wurde ein Bug gefunden, der indirekt eine Folge des mangelhaften Designs war: Eine Endlosschleife von Redirects. Die Prüfung ob, für den aktuellen Benutzer eine ``valide'' Session vorliegt wurde von mehreren Klassen eigenständig implementiert, dies fand auf unterschiedliche Art und Weise statt. Änderte sich während der Benutzung die Benutzer-IP, stellte dies für die eine Komponente eine valide Session dar, für die andere Komponente jedoch nicht. Die Controller-Methode leitete den Nutzer mangels ``valider'' Session so zur Login Seite, diese stellte jedoch eine ``valide'' Session fest und leitete den Nutzer erneut zur Controller-Methode.

Es wurde beschlossen, das Session Konzept einem grundsätzlichen Rewrite zu unterziehen. Das Wissen darüber, was eine Session darstellt, sollte gebündelt an einer zentralen Stelle der Architektur liegen, der Rest der Anwendung nur die API dieser ``zentralen Stelle'' verwenden und unter keinen Umständen selbst an Cookies oder den entsprechenden Datenbank-Entitäten manipulieren. Um sicherzustellen, dass es nicht erneut zu dem bereits festgestellten Redirect-Bug kommt, wurden diese Fälle durch Unit-Tests abgebildet.

\subsection{Login Firewall}
Die aktuelle Version unserer Login Firewall wurde einem Review durch zwei Personen unterzogen, welches zwei Stunden benötigte. Hierbei wurde ein Bug entdeckt, der ein Information Leakage zur Folge hatte: Die Firewall versetzt Benutzeraccounts nach N falschen Logins in einen Captcha-Modus. Login-Versuche auf nicht-existierende Benutzeraccounts, führten nicht zu dieser Account-``Sperre''. Aufgrund dieser funktional anderen Behandlung wäre es möglich gewesen, feststellen zu können, ob ein Account existiert oder nicht, was ein Brute-Forcing maßgeblich erleichtern würde.

Die Login-Firewall wurde angepasst (vgl. [verweis auf das architektur Dokument) und es wurde ein weiteres Review für die finale Version der Anwendung geplant, das Prüfen soll, ob alle möglichen Login-Kombinationen für einen Außenstehenden ``gleich'' sind, um ein solches Information-Leakage zu verhindern.

\subsection{Eingabevalidierung von Forms}
Um Daten aus übermittelten Forms zu empfangen, nutzt unsere Anwendung DTOs, die mit Play-Constraint-Annotations versehen sind. Über diese Annotations wird sichergestellt, dass diese Daten einem bestimmten Format entsprechen, z.B. eine valide E-Mail Adresse darstellen. Diese Validierung wurde durch eine Person einem Review unterzogen, es hat 2 Stunden benötigt.

Im Zuge des Reviews wurde festgestellt, dass das vorhandene Design Race Condition begünstigt. Die Validierungen im DTO waren nicht ausdrücklich auf ``statische'' Tests begrenzt. Es wurden teilweise Validierungen vorgenommen, die Datenbankzugriffe beinhaltet haben, z.B.: Existiert dieser Benutzername bereits? Wird im Controller die Form-Validierung\footnote{boundForm.hasErrors()} aufgerufen, ist die im DTO vorgenommene Validierung sowie der Controller-Code nicht Teil einer Transaktion. D.h. wenn die Form-Validation meldet, dass der Nutzername noch nicht existiert, ist dieser Zustand nicht mehr garantiert, wenn der Benutzer tatsächlich angelegt wird.

Auch wenn dies im vorliegenden Fall aufgrund der Unique-Constraints in der Datenbank kein Sicherheitsproblem darstellt, haben wir uns dazu entschlossen, von einem solchen Design abzusehen. Ein Design was in derartiger Weise Race Conditions begünstigt, ist objektiv schlecht. In den DTOs finden inzwischen nur noch ``statische'' Tests statt. Diese Entscheidung hat zur Entstehung der Manager-Klassen geführt. Diese bieten Methoden, die Transaktionssicher sind und werfen bsp. eine Exception, wenn der Nutzer bereits existiert (vgl. [TODO: Verweis zu der Erklärung wie wir von Controller macht alles zu den Manager Klassen gelangt sind]).

\section{Statische Codeanalyse}

Da innerhalb der Gruppe keine Präferenzen bezüglich eines Werkzeugs für die statische Codeanalyse bestand, haben wir verschiedene ausprobiert.
Die Erfahrung aus anderen Sprachökosystemen (bspw. C++) zeigt, dass es dennoch ratsam ist, unterschiedliche Werkzeuge zu verwenden, um eine breitere Menge abzudecken und ggf. \enquote{False Positives} auszuschliessen.

Die Werkzeuge, die wir nach einer kurzen Evaluation ausgesucht haben, sind:

\begin{itemize}
  \item FindBugs \autocite{FindBugs} inkl. \enquote{find-sec-bugs}-Plugin \autocite{FindBugs.FindSecBugs},
  \item Synopsis SecureAssist (ehemalig Cigital SecureAssist) \autocite{SecureAssist},
  \item SonarLint (ehemalig Sonarqube) \autocite{SonarLint}
\end{itemize}

Allerdings stossen diese Werkzeuge hier an ihre Grenzen, da sie den autogenerierten Code des Play Frameworks, Play-spezifischen Code sowie Scala nicht korrekt analysieren konnten.

\subsection{FindBugs}

Wir haben die Version 3.0.1 verwendet, die am 2018-10-16 veröffentlicht wurde.
Bei dem Plugin \enquote{find-sec-bugs} wurde Version 1.8 verwendet.

Verwendetete Einstellungen:

\begin{itemize}
  \item Analyseaufwand: Maximal
  \item Minimalster Fehlerrang: 20 - Of Concern
  \item Alle Fehlerkategorien, Filter wurden aktiviert
\end{itemize}

Da ein Grossteil der Fehler, die \enquote{FindBugs} gefunden hat, sich in den Tests, im autogenerierten Code oder den Templates vom Play Framework befindet, war es schwer, die \enquote{False Positives} herauszufiltern.
Eine gesamte Auflistung aller gefundenen Fehler kann im Anhang \ref{staticanalysis-find-bugs} eingesehen werden.
Gefunden wurden Fehler in den Kategorien \enquote{Bad Practice}, \enquote{Richtigkeit}, \enquote{Performance}, \enquote{Dodgy Code} sowie \enquote{Sicherheitsanfälligkeit durch bösartigen Code}.
In unserem eigentlichen Applikationscode wurden nur Fehler der Kategorie \enquote{Sicherheitsanfälligkeit durch bösartigen Code} gefunden, die darauf hinweisen, dass einige Variablen mit \enquote{final} deklariert werden sollten.

\subsection{Synopsis SecureAssist}

Wir haben die Version 3.3.0 verwendet, welche im am 2018-01-29 veröffentlicht wurde.
Da dieses Werkzeug im Betracht auf Sicherheitslücken von berühmten Sicherheitsexperten wie Gary McGraw entwickelt wurde, hoffen wir, dass dieses Werkzeug Lücken findet, die den anderen Werkzeugen nicht auffallen.

\subsubsection{Hardkodierte Passwörter}

In unserer Testklasse \texttt{UserManagerTest} verwenden wir ein hardkodiertes Passwort, um zu überprüfen, ob ein Nutzer sein Passwort ändern kann, zu sehen in Quellcode \ref{lst:staticanalysis-hardcoded-pw}.
Das sehen wir nicht als sicherheitsrelevanten Fehler an und ignorieren diesen daher.

\subsubsection{Query Injections}

Die Regel, die SecureAssist verwendet, um mögliche SQL Injections zu finden, scheint nur zu prüfen, ob ein SQL Statement als String verwendet wird, und ob es als \texttt{PreparedStatement} verwendet wird.
Leider überprüft es nicht, ob das als String angegebene SQL Statement überhaupt veränderbar ist; beispielsweise durch Konkatenieren eines Parameters.
Das Werkzeug hat daher ein \enquote{False Positive} in unserer \texttt{DatabaseInitialization}-Klasse gefunden, siehe Quellcode \ref{lst:staticanalysis-query-injection}.
Die Statements in dieser Klasse können nicht von einem Nutzer durch Parameter angereichert werden.

\subsubsection{Information Leakage}

Das Ausgeben des Stacktrace im Falle einer Exception sieht das Werkzeug bereits Verletzung der Vertraulichkeit, welchem wir zustimmen.
Glücklicherweise schützt Play einem in diesem Fall und gibt keine Stacktraces an einen Benutzer weiter, sofern die Applikation im \enquote{Production Mode} ausgeführt wird.
In diesem Fall wird die Exception mit einer ID ausgezeichnet, die ID wird dem Benutzer angezeigt und der Stacktrace wird in das Applikationslog geschrieben.

\subsection{SonarLint}

An dem \enquote{SonarLint}-Plugin für die IntelliJ IDE konnten keine relevanten Einstellungen verändert werden, daher wurden die Werkseinstellungen benutzt.

Die Mängel, die während des Scans unseres Quellcodes gefunden wurden, werden hier der Vollständigkeit halber aufgeführt, obwohl nur programmierstil-spezifische Fehler gefunden wurden.

\subsubsection{Verbergen des \texttt{public}-Konstruktors}

Die Klassen

\begin{itemize}
  \item \texttt{ConstraintValues},
  \item \texttt{Authentification},
  \item \texttt{LaggyDT},
  \item \texttt{Recaptcha}
\end{itemize}

sind entweder reine Utilityklassen mit statischen Methoden beziehungsweise finalen Variabeln oder implementieren eine Annotation.
Es bietet sich also an, einen \texttt{private}-Konstruktor für diese Klassen zu schreiben, damit der \texttt{public}-Konstruktor verborgen ist, und niemand ausversehen ein Objekt dieser Klassen instanziieren kann.

\subsubsection{Extrahieren von Konstanten in \texttt{final}-Variabeln}

In der \texttt{Firewall} sowie unseren \texttt{Manager}-Klassen verwenden wir Konstanten, die an mehreren Stellen verwendet werden.
Im Falle der \texttt{Manager}s handelt es sich um ähnliche String, die in einer Exception den Fehler genaür beschreiben.
Bei diesen Strings könnte man sich der \texttt{i18n}-Implementation von Play bedienen, um diese Fehlermeldungen für alle \texttt{Manager}s erreichbar zu machen, aber da Internationalisierung nicht im Umfang dieses Projekts ist, werden sie als statische, finale Variabeln extrahiert.

\section{Quelltextinspektion}

Haben wir ggf. irgendwelche Checklisten nutzen können?
Siehe

\chapter{Gefundene Mängel}

\printbibliography

% Can be used to add a list of acronyms with their description
%\glsaddall
%\deftranslation{to=German}{Acronyms}{Abkürzungsverzeichnis}
%\deftranslation{to=German}{Glossary}{Glossar}
\printacronyms[title=Abkürzungsverzeichnis,toctitle=Abkürzungsverzeichnis]
\printglossary[type=main]

%\addcontentsline{toc}{chapter}{\listfigurename}
\listoffigures      % Abbildungsverzeichnis

%s\addcontentsline{toc}{chapter}{\listtablename}
% \listoftables       % Tabellenverzeichnis

\begin{appendices}

\chapter{src/test/domainlogic/usermanager/UserManagerTest.java}
\begin{lstlisting}[language=Java,caption=Hardkodiertes Passwort in einem Test aus der Klasse \texttt{UserManagerTest},label={lst:staticanalysis-hardcoded-pw}]
@Test
public void testChangePassword() throws InvalidArgumentException {

String testUsername = "test";
String newPassword = "0123456789";
}
\end{lstlisting}

\chapter{src/app/DatabaseInitialization.java}
\begin{lstlisting}[language=Java,caption=Von SecureAssist gefundenes False Positive Beispiel für Query Injections,label={lst:staticanalysis-query-injection}]
db.withConnection(connection -> {
	Statement stmt = connection.createStatement();
	stmt.execute("SET REFERENTIAL_INTEGRITY FALSE");
	stmt.execute("TRUNCATE TABLE groupmembers");
	stmt.execute("TRUNCATE TABLE users");
	stmt.execute("TRUNCATE TABLE groups");
	stmt.execute("TRUNCATE TABLE internal_session");
	stmt.execute("SET REFERENTIAL_INTEGRITY TRUE");
	stmt.execute("SET ALLOW_LITERALS NONE");
});
\end{lstlisting}

\chapter{FindBugs Report}
\label{staticanalysis-find-bugs}
%\input{findbugs_result.pdf}

\end{appendices}

\end{document}
