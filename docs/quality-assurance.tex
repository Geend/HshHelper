\documentclass[12pt,DIV14,BCOR10mm,a4paper,twoside,parskip=half-,headsepline,headinclude,english,ngerman,bibliography=totocnumbered]{scrreprt}

\usepackage{hshhelper_base}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{document}    % hier gehts los
  \thispagestyle{empty} % Titelseite
\includegraphics[width=0.2\textwidth]{Wortmarke_WI_schwarz}

   {  ~ \sffamily
  \vfill
  {\Huge\bfseries Bericht: Maßnahmen zur Qualitätssicherung}
  \bigskip

  {\Large
  Dennis Grabowski, Julius Zint, Philip Matesanz, Torben Voltmer \\[2ex]
  Masterprojekt \enquote{Entwicklung und Analyse einer sicheren Web-Anwendung} \\
  Wintersemester 18/19
 \\[5ex]
   \today }
}
 \vfill

  ~ \hfill
  \includegraphics[height=0.3\paperheight]{H_WI_Pantone1665}

\vspace*{-3cm}

\tableofcontents  % Inhaltsverzeichnis

\chapter{Benutzte Methoden}
\section{Vier-Augen-Prinzip}
\section{Tests}

\subsection{Funktionale Tests}

Classcoverage, Branchcoverage, Linecoverage, Methodcoverage
End-to-End? Unittests? Wird DB getestet?
Welche Funktionen wurden nicht getestet?

\subsection{Tests zur Pruefung von sicherheitsrelevanten Funktionen}

Sessionmanagement?
Ist unser Cookie sicher und wirklich zufaellig?
Brute-force Schutz (Stichwort: "Firewall")
Authorization? Koennen Endpoints nur von den richtigen Privilegien angesurft werden?
Wird CSRF richtig genutzt?
Salted bcrypt richtig? Nutzen wir ausreichend Iterationen oder koennen wir mit einem Test das irgendwie knacken?
Kommt das Captcha zur richtigen Zeit? Ist das Captcha austricksbar?
Haben wir Quality rules fuer passwoerter?
Koennen wir kaputte Daten in die Forms eintragen?
Koennen wir irgendwelche Requests forgen?
Koennen SQL-Injections ausgefuehrt werden?
Setzen wir alle richtigen Security-Header?

\subsection{Penetrationstests}

Welche Penetrationstests wurden durchgefuehrt?
Gibt es ggf. automatisierbare Skripts?
Wenn ja, fuer welche Angriffe?

\section{Reviews}
\subsection{Session Konzept}
Die erste Version unseres Session Konzepts wurde einem Review unterzogen. Das Review wurde von einer Person durchgeführt und benötigte 2 Stunden. Hierbei wurde insb. ein schlechtes Design bemängelt. Die Session-Funktionalität wurde nicht von einer bzw. wenigen Klassen abgebildet, sondern auf verschiedenste Klassen verteilt: Die Login-Methode im Controller erstellte inline einen Datenbank-Eintrag sowie ein Cookie. Andere Controller-Methoden manipulierten inline die entsprechenden Einträge und entfernten nach Bedarf Cookies. Das Wissen darüber, was überhaupt eine Session darstellt war so nicht an einer zentralen Stelle im Code zu finden und entsprechend schwer zu prüfen.

Ebenfalls wurde ein Bug gefunden, der indirekt eine Folge des mangelhaften Designs war: Eine Endlosschleife von Redirects. Die Prüfung ob, für den aktuellen Benutzer eine ``valide'' Session vorliegt wurde von mehreren Klassen eigenständig implementiert, dies fand auf unterschiedliche Art und Weise statt. Änderte sich während der Benutzung die Benutzer-IP, stellte dies für die eine Komponente eine valide Session dar, für die andere Komponente jedoch nicht. Die Controller-Methode leitete den Nutzer mangels ``valider'' Session so zur Login Seite, diese stellte jedoch eine ``valide'' Session fest und leitete den Nutzer erneut zur Controller-Methode.

Es wurde beschlossen, das Session Konzept einem grundsätzlichen Rewrite zu unterziehen. Das Wissen darüber, was eine Session darstellt, sollte gebündelt an einer zentralen Stelle der Architektur liegen, der Rest der Anwendung nur die API dieser ``zentralen Stelle'' verwenden und unter keinen Umständen selbst an Cookies oder den entsprechenden Datenbank-Entitäten manipulieren. Um sicherzustellen, dass es nicht erneut zu dem bereits festgestellten Redirect-Bug kommt, wurden diese Fälle durch Unit-Tests abgebildet.

\subsection{Login Firewall}
Die aktuelle Version unserer Login Firewall wurde einem Review durch zwei Personen unterzogen, welches zwei Stunden benötigte. Hierbei wurde ein Bug entdeckt, der ein Information Leakage zur Folge hatte: Die Firewall versetzt Benutzeraccounts nach N falschen Logins in einen Captcha-Modus. Login-Versuche auf nicht-existierende Benutzeraccounts, führten nicht zu dieser Account-``Sperre''. Aufgrund dieser funktional anderen Behandlung wäre es möglich gewesen, feststellen zu können, ob ein Account existiert oder nicht, was ein Brute-Forcing maßgeblich erleichtern würde.

Die Login-Firewall wurde angepasst (vgl. [verweis auf das architektur Dokument) und es wurde ein weiteres Review für die finale Version der Anwendung geplant, das Prüfen soll, ob alle möglichen Login-Kombinationen für einen Außenstehenden ``gleich'' sind, um ein solches Information-Leakage zu verhindern.

\section{Statische Codeanalyse}

Da innerhalb der Gruppe keine Praeferenzen bezüglich eines Werkzeugs fuer die statische Codeanalyse bestand, haben wir verschiedene ausprobiert.
Die Erfahrung aus anderen Sprachökosystemen (bspw. C++) zeigt, dass es dennoch ratsam ist, unterschiedliche Werkzeuge zu verwenden, um eine breitere Menge abzudecken und ggf. \enquote{False Positives} auszuschliessen.

Die Werkzeuge, die wir nach einer kurzen Evaluation ausgesucht haben, sind:

\begin{itemize}
  \item FindBugs \autocite{FindBugs} inkl. \enquote{find-sec-bugs}-Plugin \autocite{FindBugs.FindSecBugs},
  \item Synopsis SecureAssist (ehemalig Cigital SecureAssist) \autocite{SecureAssist},
  \item SonarLint (ehemalig Sonarqube) \autocite{SonarLint}
\end{itemize}

Allerdings stossen diese Werkzeuge hier an ihre Grenzen, da sie den autogenerierten Code des Play Frameworks, Play-spezifischen Code sowie Scala nicht korrekt analysieren konnten.

\subsection{FindBugs}

Wir haben die Version 3.0.1 verwendet, die am 2018-10-16 veroeffentlicht wurde.
Bei dem Plugin \enquote{find-sec-bugs} wurde Version 1.8 verwendet.

Verwendetete Einstellungen:

\begin{itemize}
  \item Analyseaufwand: Maximal
  \item Minimalster Fehlerrang: 20 - Of Concern
  \item Alle Fehlerkategorien, Filter wurden aktiviert
\end{itemize}

Da ein Grossteil der Fehler, die \enquote{FindBugs} gefunden hat, sich in den Tests, im autogenerierten Code oder den Templates vom Play Framework befindet, war es schwer, die \enquote{False Positives} herauszufiltern.
Eine gesamte Auflistung aller gefundenen Fehler kann im Anhang \ref{staticanalysis-find-bugs} eingesehen werden.
Gefunden wurden Fehler in den Kategorien \enquote{Bad Practice}, \enquote{Richtigkeit}, \enquote{Performance}, \enquote{Dodgy Code} sowie \enquote{Sicherheitsanfaelligkeit durch boesartigen Code}.
In unserem eigentlichen Applikationscode wurden nur Fehler der Kategorie \enquote{Sicherheitsanfaelligkeit durch boesartigen Code} gefunden, die darauf hinweisen, dass einige Variablen mit \enquote{final} deklariert werden sollten.

\subsection{Synopsis SecureAssist}

Wir haben die Version 3.3.0 verwendet, welche im am 2018-01-29 veroeffentlicht wurde.
Da dieses Werkzeug im Betracht auf Sicherheitsluecken von beruehmten Sicherheitsexperten wie Gary McGraw entwickelt wurde, hoffen wir, dass dieses Werkzeug Luecken findet, die den anderen Werkzeugen nicht auffallen.

\subsubsection{Hardkodierte Passwoerter}

In unserer Testklasse \texttt{UserManagerTest} verwenden wir ein hardkodiertes Passwort, um zu ueberpruefen, ob ein Nutzer sein Passwort aendern kann, zu sehen in Quellcode \ref{lst:staticanalysis-hardcoded-pw}.
Das sehen wir nicht als sicherheitsrelevanten Fehler an und ignorieren diesen daher.

\subsubsection{Query Injections}

Die Regel, die SecureAssist verwendet, um moegliche SQL Injections zu finden, scheint nur zu pruefen, ob ein SQL Statement als String verwendet wird, und ob es als \texttt{PreparedStatement} verwendet wird.
Leider ueberprueft es nicht, ob das als String angegebene SQL Statement ueberhaupt veraenderbar ist; beispielsweise durch Konkatenieren eines Parameters.
Das Werkzeug hat daher ein \enquote{False Positive} in unserer \texttt{DatabaseInitialization}-Klasse gefunden, siehe Quellcode \ref{lst:staticanalysis-query-injection}.
Die Statements in dieser Klasse koennen nicht von einem Nutzer durch Parameter angereichert werden.

\subsubsection{Information Leakage}

Das Ausgeben des Stacktrace im Falle einer Exception sieht das Werkzeug bereits Verletzung der Vertraulichkeit, welchem wir zustimmen.
Gluecklicherweise schuetzt Play einem in diesem Fall und gibt keine Stacktraces an einen Benutzer weiter, sofern die Applikation im \enquote{Production Mode} ausgefuehrt wird.
In diesem Fall wird die Exception mit einer ID ausgezeichnet, die ID wird dem Benutzer angezeigt und der Stacktrace wird in das Applikationslog geschrieben.

\subsection{SonarLint}

An dem \enquote{SonarLint}-Plugin fuer die IntelliJ IDE konnten keine relevanten Einstellungen veraendert werden, daher wurden die Werkseinstellungen benutzt.

Die Maengel, die waehrend des Scans unseres Quellcodes gefunden wurden, werden hier der Vollstaendigkeit halber aufgefuehrt, obwohl nur programmierstil-spezifische Fehler gefunden wurden.

\subsubsection{Verbergen des \texttt{public}-Konstruktors}

Die Klassen

\begin{itemize}
  \item \texttt{ConstraintValues},
  \item \texttt{Authentification},
  \item \texttt{LaggyDT},
  \item \texttt{Recaptcha}
\end{itemize}

sind entweder reine Utilityklassen mit statischen Methoden beziehungsweise finalen Variabeln oder implementieren eine Annotation.
Es bietet sich also an, einen \texttt{private}-Konstruktor fuer diese Klassen zu schreiben, damit der \texttt{public}-Konstruktor verborgen ist, und niemand ausversehen ein Objekt dieser Klassen instanziieren kann.

\subsubsection{Extrahieren von Konstanten in \texttt{final}-Variabeln}

In der \texttt{Firewall} sowie unseren \texttt{Manager}-Klassen verwenden wir Konstanten, die an mehreren Stellen verwendet werden.
Im Falle der \texttt{Manager}s handelt es sich um aehnliche String, die in einer Exception den Fehler genauer beschreiben.
Bei diesen Strings koennte man sich der \texttt{i18n}-Implementation von Play bedienen, um diese Fehlermeldungen fuer alle \texttt{Manager}s erreichbar zu machen, aber da Internationalisierung nicht im Umfang dieses Projekts ist, werden sie als statische, finale Variabeln extrahiert.

\section{Quelltextinspektion}

Haben wir ggf. irgendwelche Checklisten nutzen koennen?
Siehe

\chapter{Gefundene Maengel}

\printbibliography

% Can be used to add a list of acronyms with their description
%\glsaddall
%\deftranslation{to=German}{Acronyms}{Abkürzungsverzeichnis}
%\deftranslation{to=German}{Glossary}{Glossar}
\printacronyms[title=Abkürzungsverzeichnis,toctitle=Abkürzungsverzeichnis]
\printglossary[type=main]

%\addcontentsline{toc}{chapter}{\listfigurename}
\listoffigures      % Abbildungsverzeichnis

%s\addcontentsline{toc}{chapter}{\listtablename}
% \listoftables       % Tabellenverzeichnis

\begin{appendices}

\chapter{src/test/domainlogic/usermanager/UserManagerTest.java}
\begin{lstlisting}[language=Java,caption=Hardkodiertes Passwort in einem Test aus der Klasse \texttt{UserManagerTest},label={lst:staticanalysis-hardcoded-pw}]
@Test
public void testChangePassword() throws InvalidArgumentException {

String testUsername = "test";
String newPassword = "0123456789";
}
\end{lstlisting}

\chapter{src/app/DatabaseInitialization.java}
\begin{lstlisting}[language=Java,caption=Von SecureAssist gefundenes False Positive Beispiel fuer Query Injections,label={lst:staticanalysis-query-injection}]
db.withConnection(connection -> {
	Statement stmt = connection.createStatement();
	stmt.execute("SET REFERENTIAL_INTEGRITY FALSE");
	stmt.execute("TRUNCATE TABLE groupmembers");
	stmt.execute("TRUNCATE TABLE users");
	stmt.execute("TRUNCATE TABLE groups");
	stmt.execute("TRUNCATE TABLE internal_session");
	stmt.execute("SET REFERENTIAL_INTEGRITY TRUE");
	stmt.execute("SET ALLOW_LITERALS NONE");
});
\end{lstlisting}

\chapter{FindBugs Report}
\label{staticanalysis-find-bugs}
%\input{findbugs_result.pdf}

\end{appendices}

\end{document}
