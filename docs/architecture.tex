\documentclass[12pt,DIV14,BCOR10mm,a4paper,parskip=half-,headsepline,headinclude,english,ngerman,bibliography=totocnumbered]{scrreprt}

\usepackage{hshhelper_base}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{document}    % hier gehts los
  \thispagestyle{empty} % Titelseite
\includegraphics[width=0.2\textwidth]{Wortmarke_WI_schwarz}

   {  ~ \sffamily
  \vfill
  {\Huge\bfseries Architekturbeschreibung}
  \bigskip

  {\Large
  Dennis Grabowski, Julius Zint, Philip Matesanz, Torben Voltmer \\[2ex]
  Masterprojekt \enquote{Entwicklung und Analyse einer sicheren Web-Anwendung} \\
  Wintersemester 18/19
 \\[5ex]
   \today }
}
 \vfill

  ~ \hfill
  \includegraphics[height=0.3\paperheight]{H_WI_Pantone1665}

\vspace*{-3cm}

\tableofcontents  % Inhaltsverzeichnis

\chapter{Architekturaufbau}
\section{Klassendiagramm}
Dieses Architekturdiagramm verzichtet zugunsten der Übersichtlichkeit auf die Abhängigkeiten zwischen den Klassen. Es dient lediglich zur Veranschaulichung der Top-Level-Architektur und zur Illustration der wichtigsten Klassen. Wie die, durch Farben abgetrennten logischen Gruppierungen der Klassen im Zusammenhang stehen, wird unter der Abbildung textuell erklärt.

\includegraphics[width=0.73\paperwidth]{resources/class_diagram.png}
\label{architecture:class_diagram}

Zu jedem Controller gibt es einen Manager in der Domain Logik. Dieser enthält jegliche Logik zur Abarbeitung der Anfrage und liefert auftretende Fehler über eine Exception zurück. Datenbankzugriff erfolgt somit niemals von einem Controller, sondern immer aus dem zugehörigen Manager. Beim Sessionmanager handelt es sich um einen Spezialfall, da das Session Konzept ein integraler Bestandteil der Anwendung ist und somit von sehr vielen stellen aus Verwendung findet. Das Gleiche gilt für das PasswordSecurityModule, was beispielsweise beim Einloggen, Erstellen, oder Passwortreset Benutzers benötigt wird. Daher wurden diese beiden Klassen unter Cross-Cutting-Concerns zusammengefasst. Zugriff auf diese beiden Klassen kann sowohl von Controllern aus erfolgen als auch von Managern in der Domain Logik. Die folgenden Sequenzdiagramme geben weitere Einsicht in das Zusammenspiel der Klassen untereinander.

\section{Benutzer erstellen Sequenzdiagram}

\includegraphics[width=0.7\paperwidth]{resources/createuserseq_diagram.png}

Beim Anlegen eines neuen Benutzers wird zuerst durch ein HTTP GET die Form angefragt. Dies ist notwendig um ein gültiges CSRF-Token zu erhalten, welches beim anschließenden HTTP POST mitgeliefert werden muss. Auch hier wird bereits, wie aus dem Sequenzdiagramm ersichtlich, überprüft ob der anfragende User authentisiert ist. Ist das der Fall, wird eine HTML Form zurückgeliefert, die ausgefüllt und durch einen weiteren Anfrage wieder an den Server geschickt wird. Hier wird zuerst über die in Play integrierte Möglichkeit mit Annotations eine erste Validierung der Eingaben vorgenommen. Somit werden bereits zu einem frühen Zeitpunkt Eingaben mit nicht unterstützten Zeichen oder ungültiger Länge herausgefiltert und dem Benutzer durch Anzeigen von Fehlermeldungen direkt am Eingabefeld mitgeteilt. Sind alle Eingaben korrekt, wird der Aufruf weiter an den Manager geleitet. Dieser befragt zuerst die Policy ob der authentisierte Benutzer autorisiert ist einen neuen Benutzer anzulegen, generiert ein neues Passwort, Hashed es und legt in einer Transaktion einen neuen Benutzer an. Das Klartext Passwort wird zurückgegeben und dem Administrator angezeigt um dies dem neuen Benutzer zukommen zu lassen.

\section{Login Sequenzdiagram}
\includegraphics[width=0.70\paperwidth]{resources/loginseq_diagram.png}

Das Login Sequenzdiagramm zeigt den Fall, dass der Benutzer bereits mehrfach das Passwort falsch eingegeben hat und ein Captcha lösen muss. In der Antwort, die auf die erste GET Anfrage folgt, sind sowohl das CSRF-Token als auch das HTML zum Lösen des Captchas enthalten. In der darauffolgenden POST Anfrage wird die Captcha-Information, sowie der Benutzername und das Passwort als Form input mitgeliefert. Bei beiden Anfragen wird noch sichergestellt, dass der Benutzer nicht bereits eine gültige Session besitzt, um mehrfache Logins zu vermeiden. Die Eingaben werden, wie auch schon bei Create User, zuerst durch Annotations validiert und anschließend an den Login Manager weitergereicht. Diese berechnet unabhängig davon ob der Benutzer existiert oder nicht den Hash des Klartextpassworts vergleicht diesen mit dem Benutzer falls vorhanden. Anschließend wird die LoginFirewall befragt, ob es Unstimmigkeiten für diesen Benutzer oder die anfragende IP-Adresse gibt. In diesem Fall liefert diese Verify zurück, was bedeutet das für diesen Benutzer ein Captcha gelöst werden muss. Deshalb wird überprüft, ob es erfolgreich gelöst wurde und dann beim SessionManager durch den Aufruf von startNewSession eine neue Session erzeugt. Damit wurde der Login erfolgreich abgeschlossen.

\chapter{Sicherheitsmassnahmen}

\section{Login Firewall}
Der Login einer Web-Anwendung ist potentiell anfällig für Brute-Force-Angriffe, die darauf abzielen, eine valide Benutzername/Passwort Kombination zu finden. Aus diesem Grund, muss die Anwendung fehlerhafte Zugriffsversuche protokollieren und wenn eine Häufung selbiger auftritt, Maßnahmen ergreifen, um den Angriff zu verlangsamen oder gar zu stoppen. Die ergriffene Maßnahme sollte so gewählt werden, dass sie nicht selbst einen Angriffsvektor darstellt, wie z.B. das vollständige Sperren eines Accounts nach N falschen Logins - man könnte so legitime Nutzer vorsätzlich an der Benutzung der Anwendung hindern (Denial of Service).

Aus diesem Grund verfügt unsere Anwendung über eine Komponente\footnote{policy.ext.loginFirewall}, die falsche Logins protokolliert und eine der folgenden Maßnahmen ergreift:

\begin{itemize}
\item Spezifischen Benutzer-Account in Captcha-Mode versetzen
\item Spezifische IP-Addresse in Captcha-Mode versetzen
\item Spezifische IP-Addresse von Logins ausschließen
\end{itemize}

Beim Captcha-Mode handelt es sich um eine Maßnahme, bei der ein Login lediglich möglich ist, wenn zugleich ein Google Recaptcha gelöst wird. Eine vollständige Sperrung eines Accounts findet durch unsere Firewall so nicht statt. Es wurde die Annahme getroffen, dass das automatisierte Lösen der Recaptchas zu aufwändig/teuer für einen Angreifer ist. Zugleich ist das ``unnötige'' Lösen eines Captchas für das Opfer ein vertretbares Hindernis.

Lediglich IP-Addressen werden als schärfste Maßnahme vollständig von Logins ausgeschlossen. Sofern ein Angreifer nicht die gleiche IP-Adresse wie sein Opfer verwendet, kann er sich höchstens selbst vom Dienst ausschließen. Sollte eine Sitation vorliegen, bei der sich eine Vielzahl von Nutzern eine IP-Adresse teilt, besteht die Möglichkeit diese von der vollständigen Sperre auszuschließen.

Die interne Datenstruktur der Login Firewall ist darauf optimiert, möglichst wenig Speicher zu verwenden und nutzt quasi Buckets, um aggregierte Informationen über Login-Versuche zu speichern. Die Buckets bilden ein fixes Zeitinterval ab. Führt ein Angreifer 1 Million fehlerhafte Logins in 10 Minuten durch, werden lediglich zwei Datenbank-Einträge erstellt: Einen mit Bezug auf den betroffenen Nutzer-Account und einen mit Bezug auf die IP des Angreifers. Beide Einträge verfügen über eine Zählvariable, die jeweils die Anzahl der fehlerhaften Logins beinhält.

Der Verweis auf den Nutzer-Account findet über die numerische und eindeutige ID statt, über die jeder Account verfügt. Jener Fallgestaltung, bei der ein Login bei einem nicht-existenten Account erfolgt, wurde ebenfalls Rechnung getragen. Hierbei ist es erforderlich, dass die Firewall exakt so funktioniert, wie bei existierenden Accounts, um ein Information-Leakage zu verhindern: Würde die erste Maßnahme nie oder anders greifen als bei tatsächlich existenten Accounts wäre es möglich, zu prüfen ob ein Account bzw. der dazu korrospondierende Benutzername tatsächlich existiert.

Zu diesem Zweck wird bei nicht-existenten Accounts der Benutzername mittels Hashing auf eine ``virtuelle'' User-ID gemappt. Die User-ID wird über ein Long repräsentiert, es wird jedoch ausschließlich der positive Zahlenraum verwendet. Vom Username wird der md5-Hash gebildet, die ersten 8 Byte werden als Long verwendet und ggf. invertiert. Der so resultierende negative Long-Wert wird in diesem Fall als Grundlage für die Protokollierung fehlerhafter Logins verwendet. Dass md5 kryptografisch bereits längst als geknackt gilt ist irrelevant, wir machen uns lediglich die gute Streuung und hohe Geschwindigkeit von md5 zu eigen.

\section{Sessionkonzept}
Integraler Bestandteil unserer Anwendung ist eine Session-Funktionalität. Theoretisch bietet Play bereits eine Implementierung unter Verwendung von JWT\footnote{\url{https://jwt.io/}} mit der es möglich ist, unter Verwendung von signierten Cookies Daten im Client-Browser zu speichern. Die Sicherstellung der Authentifizierung ist jedoch für nahezu jede Funktionalität unserer Anwendung von Bedeutung. Aus diesem Grund wurde das Session Konzept soweit abstrahiert, dass eine Java-Annotation über einer Controller-Klasse oder einzelnen Controller-Methoden ausreicht, um zu garantieren, dass ausschließlich authentifizierte Nutzer auf selbige zugreifen können.

Die Annotation bewirkt, dass der korrospondierende Request \underline{vor} Errichen der dazugehörigen Controller Methode abgefangen wird und eine Prüfung durchgeführt wird, ob der Absender authentifiziert ist. Ist dies nicht der Fall, wird die weitere Ausführung abgebrochen und der Nutzer auf die Login-Seite weitergeleitet. Ansonsten wird der Request an den entsprechenden Controller weitergereicht.

Zur Umsetzung dieser Funktionalität setzen wir auf dem Session-Konzept von Play auf. Wird eine neue Session initialisiert, wird ein dazugehöriger Eintrag in der Datenbank erstellt. Dieser beinhaltet das Initialierungsdatum, die dazugehörige IP und User-ID sowie eine kryptografisch sichere UUID als Identifikator. Die UUID wird in der Play-Session persistiert. Ein Angreifer kann aufgrund der JWT-Signatur nicht beliebige UUIDs an unsere Anwendung schicken.

Die UUID selbst dient als 2nd Layer of Defense: Sollte die JWT-Signatur geknackt werden, muss der Angreifer noch eine in der Datenbank enthaltene UUID erraten. Selbst, wenn er diese Hürde meistert, muss er noch die dazugehörige IP-Addresse kennen sowie über diese auf unsere Anwendung zugreifen können und dies in einem engen Zeitfenster schaffen, da die Lifetime einer Session begrenzt ist.

Die Anwendung verfügt über eine Sicht, die dem Nutzer sämtliche ``aktive'' Sessions anzeigt und ihm die Möglichkeit bietet, diese nach Bedarf einzeln zu entfernen. Ein Logout-Vorgang führt ebenfalls zu der Entfernung der korrospondierenden Session. Um eine Vermüllung der Datenbank zu vermeiden, läuft im Hintergrund ein Prozess, der in festen Zeitintervallen Sessions aus der Datenbank entfernt, die ``veraltet'' sind, denn wenn der Benutzer sich nicht ausloggt, sondern einfach den Browser schließt, kann unsere Anwendung keine Kenntnis davon erlangen.

\section{Content Security Policy}
Play verwendet standardmäßig eine sehr restriktive Content-Security-Policy, die XSS-Angriffe maßgeblich erschwert: Inline-Javascript wird vom Client-Browser grundsätzlich blockiert, es ist lediglich möglich, ein externes Script in eine HTML-Seite einzubinden, das jedoch von der gleichen Top-Level-Domain stammen muss. Zugleich muss dieses Script explizit Javascript als Content-Type im HTTP-Header benennen.

Da unsere Anwendung zum jetzigen Zeitpunkt nur mittelbaren Gebrauch von JavaScript macht, haben wir uns dazu entschlossen die Content-Security-Policy zu verschärfen: JavaScript wird grundsätzlich nicht mehr ausgeführt, es sei denn, es handelt sich um die JavaScript-Libraries von Recaptcha. Zu diesem Zweck haben wir die entsprechenden Quell-Urls auf die Whitelist gesetzt und somit gleichzeitig die Annahme getroffen, dass wir Google als Host-Provider der Libraries vertrauen\footnote{Erforderliche Urls für die CSP Whitelist: \url{https://developers.google.com/recaptcha/docs/faq}}.

Ebenso haben wir uns entschlossen, Browser, die Content Security Policy nicht unterstützen von unserer Anwendung auszuschließen. Hiervon sind nur hinreichend alte Browser betroffen\footnote{Siehe \textquote{Browser compatibility} \url{https://developer.mozilla.org/en-US/docs/Web/HTTP/CSP}}.

\section{Kryptografisch relevanten Informationen}

\textcolor{red}{
Wie stellen diese sicher, dass Informationen usw nicht geklaut/geknackt/abgehört/entwendet werden können?
Wie sieht es mit unserer Schlässelverwaltung aus?
Wie nutzen wir unsere Cookies? Was machen unsere Cookies genau?
Wann setzen wir sie?
}

\subsection{HshHelper Passwörter}
Die Passwörter, die Benutzer verwenden um sich bei HshHelper zu authentisieren, werden grundsätzlich nur als Hash persistiert. Konkret wird die Hashfunktion bcrypt zum Hashen der Passwörter verwendet.

Um ein Passwort mit bcrypt zu Hashen muss zunächst ein Salt generiert werden. Neben dem Salt und dem gehashten Passwort wird bei bcrypt außerdem noch die bcyrpt Version und die Anzahl der Runden gespeichert. Über die Anzahl der Runden kann die Laufzeit die bcrypt benötigt um ein Passwort zu hashen beeinflusst werden.

Die verwendete Bibilithek ist jBCrypt von mindrot.org (org.mindrot.jbcrypt) in der Version 0.4. Sie verwendet intern die Java Klasse SecureRandom als CPRNG.

Auch zur Generierung der initalen (und temporären) Benutzer Passwörter beim Anlegen von Benutzer werden wird SecureRandom als Basis verwendet. Dafür zuständig ist die Klasse \textit{PasswordGenerator}. Die generierten Passwörter können die Zeichen a-z, A-Z, 0-9 und die Sonderzeichen \textit{!\%?\#-\_*+} enthalten.

\subsection{CSRF Tokens}
Play verwendet zum Generieren von CSRF Tokens die Java Klasse SecureRandom als CPRNG:

\begin{lstlisting}[caption={Methode zum Generieren von Tokens. Aus DefaultCSRFTokenSigner, Play 2.6.20},captionpos=b]
  def generateToken: String = {
    val bytes = new Array[Byte](12)
    random.nextBytes(bytes)
    new String(Hex.encodeHex(bytes))
  }
\end{lstlisting}
Dieser Token wird allerdings nicht direkt verwendet. Stattdessen wird er mit einer nonce Konkateniert. Das Ergebniss wird anschließend mittels HMAC-SHA1 und einem privatem Schlüssel signiert.

\begin{lstlisting}[caption={Methode zum Signieren von Token. Aus DefaultCSRFTokenSigner, Play 2.6.20},captionpos=b]
  def signToken(token: String): String = {
    val nonce = clock.millis()
    val joined = nonce + "-" + token
    signer.sign(joined) + "-" + joined
  }
\end{lstlisting}


Das Format eines Play CSRF Token ist demnach
\begin{lstlisting}
<signature> - <nonce> - <token>
\end{lstlisting}


Das Token (aus Listing TODO) wird nur ein mal für eine Session generiert. Es bleibt innerhalb der Session immer gleich. Da das nonce auf der Systemzeit basiert, ändert sich diese jedoch mit jedem Request, was zu unterschiedlichen Signaturen führt.

Um ein Token zu prüfen wird erneut die Signatur über dem Token und dem Nounce gebildet und mit der empfangenen Signatur verglichen. Das modifizieren eines CSRF Tokens wird somit erkannt.



\subsection{Play Cookies}
Play verwendet ein JWT (Json Web Token) als Session Cookie mit dem Namen \textit{PLAY\_SESSION}. Es ist durch eine HMAC-SHA256 Signatur gegen Manipulationen geschützt. Das Cookie wird durch HshHelper für die Implementierung des Sessionkonzepts genutzt. Außerdem sind im JWT das aktuell gültige CSRF Token und zwei Zeitstempel enthalten.


Neben dem Session Cookie gibt es noch das Flash Cookie \textit{PLAY\_FLASH}, was allerdings in der aktuellen Iteration keinerlei Anwendung findet. Der Error-Handling-Code verwendet zwar die Flash-Scope um Fehlermeldungen über eine Klassengrenze hinweg verfügbar zu machen, diese Daten werden aber innerhalb einer Anfrage direkt wieder gelesen und landen somit niemals beim Client.

Die Dokumentation von Play vermerkt, dass das Flash Cookie nicht signiert wird. \autocite{JavaPlayFlashDocu}
\blockquote{
The Flash scope works exactly like the Session, but with two differences: \\
\textbf{-} data are kept for only one request, \\
\textbf{-} the Flash cookie is not signed, making it possible for the user to modify it.
}
Dies hat sich allerdings bei einem Test als falsch herausgestellt. Sowohl wird das Flash Cookie in unserer Anwendung signiert als auch validiert, wenn es vom Client bei einer weiteren Anfrage wieder an den Server geschickt wird.

\subsection{Schlüsselmanagement}
Für das System sind mehrere Schlüssel und Zugangsdaten notwendig:

\begin{itemize}
	\item Der private Schlüssel zum signieren der Play Cookies
	\item Der private Schlüssel für reCaptcha
	\item Der öffentlicht Schlüssel für reCaptcha
	\item Login Credentials für den E-Mail Server
	\item Login Credentials für die Datenbank
\end{itemize}

Die Schlüssel und Zugangsdaten liegen alle in der Datei \textit{application.conf}.

\section{Eingabevalidierung}

\section{Ggf. architekturielle Gegenmassnahmen gegen bestimmte Angriffe}

\chapter{Implementierte Zusatzfunktionalität}

\textcolor{red}{Nutzer kann Gruppe selbst verlassen}
Nutzer können aktive Sessions betrachten und ggf. invalidieren (stichwort usability-relevantes securitykonzept)

\chapter{Verworfene Entwürfe}

\section{Sessionkonzept}
Aufgrund von Datenschutzbedenken haben wir zunächst die Speicherung der mit einer Session-Verknüpften IP-Addresse im JWT-Cookie selbst forciert. Wir waren der Annahme, die IP Addresse sei ein personenbezogenes Datum und die Speicherung von selbigen in unserer Datenbank zumindest fragwürdig. Die Verlagerung der Speicherung auf den Cookie-Speicher des Client-Browsers wäre eine potentielle Umgehungsstrategie für diese rechtliche Problematik gewesen: Die IP Addresse wird zwangsläufig vom Nutzer bei jedem Request ``übertragen'', eine doppelte Übertragung würde ``den Braten auch nicht mehr fett machen''. Herr Prof. Dr. Peine hat uns jedoch mitgeteilt, dass Datenschutzbedenken für dieses Projekt Out-Of-Scope wären. Aus diesem Grund wurde diese Idee verworfen, wir speichern die IPs in unserer Datenbank.

Ursprünglich verfügte eine in unserer Datenbank abgebildete Session über eine numerische ID, die inkrementell aufsteigend war. Das JWT-Token beinhaltet den Schlüssel der korrospondierenden Session-Entität in der Datenbank. Würde ein Angreifer die JWT Signatur knacken, könnte er leicht passende IDs erraten: Er müsste sich anmelden, wüsste dann, welche ID ``aktuell'' ist und könnte anhand dieser Information passende IDs ausprobieren. Wir haben diese Implementierung zugunsten von kryptografisch sicheren UUIDs verworfen, die ein 2nd Layer of Defense darstellen (vgl. [verweis auf session-konzept einfügen]).

\printbibliography

% Can be used to add a list of acronyms with their description
%\glsaddall
%\deftranslation{to=German}{Acronyms}{Abkürzungsverzeichnis}
%\deftranslation{to=German}{Glossary}{Glossar}
\printacronyms[title=Abkürzungsverzeichnis,toctitle=Abkürzungsverzeichnis]
\printglossary[type=main]

%\addcontentsline{toc}{chapter}{\listfigurename}
\listoffigures      % Abbildungsverzeichnis

%s\addcontentsline{toc}{chapter}{\listtablename}
% \listoftables       % Tabellenverzeichnis

\end{document}
