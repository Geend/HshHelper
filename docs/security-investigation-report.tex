% arara: pdflatex: { shell: true, draft: true }
% arara: makeglossaries
% arara: biber
% arara: pdflatex: { shell: true, synctex: true }
% arara: pdflatex: { shell: true, synctex: true }

\documentclass[12pt,DIV14,BCOR10mm,a4paper,parskip=half-,headsepline,headinclude,english,ngerman,bibliography=totocnumbered]{scrreprt}

\usepackage{hshhelper_base}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{document}    % hier gehts los
  \thispagestyle{empty} % Titelseite
\includegraphics[width=0.2\textwidth]{Wortmarke_WI_schwarz}

   {  ~ \sffamily
  \vfill
  {\Huge\bfseries Sicherheitsuntersuchungsbericht: Applikation \enquote{HsH-Helper} der Gruppe B}
  \bigskip

  {\Large
  Dennis Grabowski, Julius Zint, Philip Matesanz, Torben Voltmer \\[2ex]
  Masterprojekt \enquote{Entwicklung und Analyse einer sicheren \\Web-Anwendung} \\
  Wintersemester 18/19
 \\[5ex]
   \today }
}
 \vfill

  ~ \hfill
  \includegraphics[height=0.3\paperheight]{H_WI_Pantone1665}

\vspace*{-3cm}

\tableofcontents  % Inhaltsverzeichnis

\chapter{Ausgelieferte virtuelle Maschine ist nicht benutzbar}

Innerhalb der VM können die Aktionen \enquote{Nutzer anlegen} sowie \enquote{Datei hochladen} nicht verwendet werden, da beide bei normaler, erwarteter Nutzung zu einem Fehler führen, wie in Anhang \ref{createuser_fail_1} sowie \ref{upload_fail_1} zu sehen ist.
Da wir bereits wussten, dass der seperat ausgelieferte Quellcode funktioniert, waren wir dementsprechend schockiert. 
Diese Fehler bestehen auch, wenn man den Quellcode aus der VM extrahiert und auf seinem Hostrechner via SBT oder IntelliJ startet.
Komischerweise hat ein \texttt{diff} bewiesen, dass kein Unterschied zwischen den beiden vorliegenden Quellen besteht.

Aus Interesse haben wir daher versucht, die Ursache des Fehlers herauszufinden, konnten den Ursprung allerdings nicht finden.
Ein Symptom ist zumindest, dass bestimmte Felder nicht korrekt aus dem HTML-Formular gelesen werden konnten.
Beim Anlegen eines neuen Nutzers ist während des Debuggings zumindest das Feld \enquote{username} in dem \texttt{AddUserForm}-Objekt leer, obwohl es im \texttt{Form<AddUserForm>}-Objekt noch vorhanden ist.
Wir schätzen, dass das Problem auf nicht vorhandene Getter/Setter der selbst geschriebenen Form-Klassen zurückzuführen ist, da diese nicht ausgeführt werden konnten, als wir diese durch die Funktion \enquote{Execute Code} während des Debuggings ausführen wollten.
Ein weiteres Indiz für diese Annahme ist, dass genau die Getter/Setter des jeweils fehlendem Feld nicht vorhanden sind.
Desweiteren sind die SBT Versionen gleich, Quellcode-Unterschiede bestehen wie bereits beschrieben nicht und der Fehler tritt innerhalb und ausserhalb der VM auf, sofern man den Quellcode aus der VM nimmt.

Es ist möglich, dass weitere Aktionen innerhalb der VM nicht funktionieren. Wir hatten nach diesen 2 Aktionen aufgehört, da sie essentiell wichtige Funktionen für den HsH-Helper sind.
Die hier gefundenen Fehler beziehen sich daher auf den seperat mitgelieferten Quellcode, da dieser nicht unter dieser Problematik leidet.

Es stellte sich später heraus, dass die Probleme durch Löschen des mit ausgeliefertem \texttt{target} Ordners im Hauptverzeichnis des Projekts behoben werden können.


\chapter{Eingesetzte Methoden und Werkzeuge}


\chapter{Funktionale Fehler}


\section{Dateien}

\begin{enumerate}
 \item Speicherplatzlimit kann niemals angepasst werden, da Änderungen an dem Userobjekt nicht persistiert werden (fehlender \texttt{save()}-Call)
  \item Speicherplatz-Limit Default Wert ist in byte angegeben (1073741824). Das würden ca einem GB entsprechen. Gerechnet wird allerdings überall in Megabyte. Damit ist das Standard-Limit effektiv 1 PB. Da man das Limit nicht ändern kann ist es somit so gut wie nutzlos.
  \item 1 Byte-Datei zaehlt so viel wie 1-Megabyte File
  \item Beim Überschreiben einer Datei durch einen anderen Nutzer wird der Speicherplatzverbrauch falsch kalkuliert. Der Nutzer, der die Datei überschrieben hat, bekommmt die Differenz gutgeschrieben, während beim originale Besitzer der Datei keine Änderungen am Speicherplatzverbrauch vorgenommen werden. Dadurch kann ein Benutzer sein Speicherplatz-Limit erhöhen: Er muss nur Dateien von anderen Benutzer auf die er schreibberechtigung hat mit kleineren Dateien überschreiben.
  \item Beim Passwort Reset ist in der URL ein Slash zu viel. Dieser muss zuerst manuell entfernt werden bevor ein Passwort Reset durchgeführt werden kann. \enquote{http://localhost:9000//password/forgot/U69O...ZNcUBcK2}
  \item Da die Laengenbegrenzung eines Dateinamens die Dateiendung ignoriert, kann ein Dateiname beliebig lang gestaltet werden.
  \item Es ist Benutzern problemlos möglich, mehrere Dateien mit dem gleichen Namen hinzuzufügen. Der für den Upload zuständige Controller-Code erhält vom Anwender einen expliziten Dateinamen (A) und den Namen der ausgewählten Datei (B). Die Anwendung prüft nun, ob der Nutzer bereits eine Datei besitzt, dessen Name A entspricht. Ist dies nicht der Fall, wird die Dateiendung aus B extrahiert und eine Datei erzeugt, die einen zusammengesetzten Namen besitzt: A + \enquote{.} + extension(B).
  Wiederholt man den Upload, prüft die Anwendung erneut, ob der Benutzer eine Datei mit dem Namen A hat - was natürlich nicht der Fall ist, denn der endgültige Name der Datei entspricht nicht A.
  Die Dateianzeige lässt den Eindruck entstehen, es würde nur eine Datei zu jedem Namen existieren. Dies ist der Verwendung einer TreeMap geschuldet: Die Anwendung lädt alle Dateien, die zum Benutzer gehören und speichert diese als Key in der TreeMap. Die TreeMap stellt die Eindeutigkeit der Keys über die compareTo Methode der entsprechenden Keys bzw. Files sicher. Diese wurde von der anderen Gruppe überschrieben und beinhaltet für den Vergleich lediglich den Dateinamen und den Owner. D.h. wenn man 10 Dateien mit dem gleichen Namen erzeugt, befindet sich in der Treemap nur eine Datei und nur diese wird so angezeigt. Wird die Datei gelöscht, wird die vorherige angezeigt.
  \item Beim Hochladen von Dateien können die Berechtigungen nicht direkt vergeben werden (nicht in EINEM Request!!!)
  \end{enumerate}



\section{Gruppen}
\begin{enumerate}
\item Admin-Gruppe ist löschbar, wodurch die Applikation effektiv unbenutzbar ist. Es gibt zwar eigentlich eine Prüfung, ob versucht wird die Admin-Gruppe zu löschen, diese kann aber einfach umgangen werden. Trägt man im Gruppe-Löschen Formular eine Variation des Gruppennamens ein, die nicht exakt \enquote{admin} entspricht (wie zum Beipiel \enquote{aDmin}, wird die Gruppe gelöscht. Siehe die Funktion \texttt{isDeletableGroup} in \texttt{GroupManagerService}. Da bei Aufruf jeder Seite die Gruppe geladen wird, funktioniert nach dem Löschen der Gruppe keine Seite mehr. Es gibt eine NullPointerException in der \texttt{isAdmin} Methode in \texttt{Authorization}.
\item All-Gruppe ist, analog zur Admin-Gruppe, löschbar. Die Anwendung ist danach aber nicht ganz so kaputt.
\item Gruppen, für die Dateiberechtigungen angelegt wurden können nicht vollständig gelöscht werden. Im Code werden manuell Owner der Gruppe und Mitglieder der Gruppe gelöscht. Zu diesem Zeitpunkt ist die Gruppe \enquote{halb} gelöscht. Der anschließende \texttt{delete} Aufruf schlägt aber fehl, da Integriätsbedingungen in der Datenbank durch das löschen verletzt werden würden. Es wird eine Exception geworfen, aber die Gruppe hat schon keinen Owner mehr. Sie wird dem Admin noch angezeigt, aber sie ist nichtmehr aufrufbar.
\end{enumerate}

\section{Single Sign On}
\begin{enumerate}
 \item Single Sign On ist Hardcoded für die zwei in den Anforderungen gestellten Testfälle. Trotzdem kann man in der Oberfläche den Namen für den Benutzer- und Passwort Parameter festlegen ohne tatsächliche Auswirkungen.
  \item Sollten in der URL ein Fehler vorliegen wird eine Exception geworfen. Da es sich bei der uns hier vorliegenden Anwendung um eine Debug Version wird die Exception mit teilen des Quellcodes angezeigt. Nutzer, eingeschlossen Administratoren, sollten niemals Java Exceptions einsehen können.
  \item Beim Hinzufügen eines Webservices wird, auch wenn alle Eingaben korrekt sind und ein Webservice hinzugefügt wird, eine Fehlermeldung zurückgegeben.
     \item Werden invalide Login-Daten für Webservices eingetragen, gibt es beim Versuch sich mit dem Single-Signon anzumelden eine Exception.
\item Es können pro Webservice nur ein mal Zugangsdaten hinterlegt werden. Beim Versuch ein zweites Mal Zugangsdaten für einen Webservice zu speichern, wird nur der Statuscode 400 (badRequest) und eine leere Seite zurück gegeben.
 \end{enumerate}
 
 \section{Passwort Reset}
\begin{enumerate}
 \item Das Passwort eines Nutzers kann zurückgesetzt werden noch bevor ein Passwort Reset durchgeführt wurde. Dies kann dazu führen das Benutzer Zugriff auf ihren Account bekommen noch bevor ein Administrator ihnen das initiale Passwort mitteilt. Das initiale Passwort verliert somit jegliche Bedeutung.
 \end{enumerate}
 



\section{Sonstiges}

\begin{itemize} 
  \item Admin scheint nicht in der Lage zu sein, einen Nutzer zu löschen.  
  \item Benutzer, die Dateien hochgeladen haben können nicht gelöscht werden. Es wird versucht die Dateien des zu löschenden Benutzer mit dem Benutzername des löschenden Benutzer zu löschen. Der hat dazu aber nicht die Berechtigung, da er nicht Owner der Datei ist. (siehe AdminService.java Zeile 143. Hier wird \texttt{actor} übergeben. Korrekt wäre \texttt{credentials})
  \item Eventuell möglich via Parallelisierung / Bulk-Requests eine Datei mit dem selben Namen hochzuladen
  \item Nutzer Admin hat PW admin1 - entspricht nicht der Anforderung 4.4.
  \item CSRF-Token funktionieren teilweise nicht - abhängig vom Browser?
  \item Es ist unmöglich, einen Nutzer, der in der Administratorgruppe ist, zu löschen, wenn man als "admin" eingeloggt ist. Diese Operation führt zu einem Fehler laut Web-GUI, der zur folge hat, dass dieser Nutzer nicht mehr in der "Alle"-Gruppe ist, aber in allen anderen Gruppen bestehen bleibt.
  \item Es wurde eine Debug-Version ausgeliefert, der Aufruf eines nicht existierenden Pfads führt essentiell dazu, dass die Inhalte der Routes-Datei ausgegeben werden.
  \item Beim Anlegen eines Benutzers muss der Admin explizit ein Passwort vergeben. Laut den Anforderungen (Punkt 6.1) wird ein automatisch generiertes Passwort verlangt.
  

\end{itemize}

\chapter{Sicherheitslücken}

\begin{enumerate}
  \item Verschlüsseln sie die Passwörter mit dem selben Key, mit dem auch das JWT Cookie verschlüsselt wird? Bissl \enquote{gefährlich}.
  \item DOS auf Benutzerkonten: Benutzer können dauerhaft von der Seite ausgesperrt werden durch mehrfache Eingabe eines falschen Passworts. Ein möglicher Angriff wäre den Administratoraccount davon abzuhalten, einen Benutzer zu löschen.
  \item Beim Hashing des Passworts für die Datenbank wir nur eine Runde des SHA256 Hashs ausgeführt. Dies macht einen Brute-Force-Angriff im Falle einer kompromittierten Datenbank einfacher für den Angreifer.
  \item Um das salt fürs Hashing zu generieren wird zwar SecureRandom verwendet aber der Wert aus SecureRandom wird nur als Index ins PASSWORD\_CHARS Array verwendet. Somit ist der Keyspace des salts eingeschränkt und einfacher zu erraten.
  \item Gegner speichern Passwort-Reset-Tokens in Hashmap. Als Key hierfür dient der Token selbst. Token werden allerdings nur dann gelöscht, wenn sie verwendet werden. Man kann theoretisch beliebig viele Tokens ohne Begrenzung erzeugen (Schutz matched beim ersten gefundenen Token) und so den Speicher des Servers von außen füllen und einen Absturz provozieren.
  
  \item Sollte ein Benutzer einmal ein Cookie mit einer Emailadresse haben ist dieses gültig unabhängig davon ob der Benutzer in der Zwischenzeit aus der Datenbank gelöscht und neu erstellt wird. 

Angriffsszenario 1: Max Mustermann studiert an der Hochschule Hannover und logged sich beim HsH-Helper mit seiner Email Adresse max.musterman@hsh-hannover.de ein. Zwei Jahre nachdem Max Mustermann sein Studium abgeschlossen hat beginnt ein weiterer Max Mustermann sein Studium und bekommt die selbe Email Adresse zugewiesen. Max Mustermann 1 hat vollen zugriff auf den Account von Max Mustermann 2. 

Angriffsszenario 2: Admin legt Nutzer an, meldet sich an und speichert Cookie. Admin löscht Nutzer, legt ihn erneut an und händigt Daten an Benutzer aus.
  \item Das Cookie ist auch dann noch gültig, wenn der entsprechende Benutzer gelöscht wurde. Der Benutzer kann weiterhin die Startseite sowie den Datei-Hochladen-Dialog aufrufen. Er kann den Gruppe-Hinzufügen-Dialog eingeschränkt benutzen: Durch Angabe eines Gruppennamens kann er feststellen, ob dieser existiert. Er kann jedoch leider keine neuen Gruppen erstellen. Dies ist scheinbar dem Zufall geschuldet, eine explizite Prüfung die dies verhindert existiert nicht.
  \item Policy metrics wie die Timeoutzeit nach mehrfachen ungültigen Logins sollten nicht an den User weitergegeben werden. Dadurch wird es für ein Angreifer einfacher, Brute-Force Angriffe durchzuführen. \autocite[Loc. 5087]{book:wahh}
  \item Der beim Upload einer Datei angegebene Dateiname wird um die Dateiendung (z.B. ".pdf") der hochgeladenen Datei ergänzt. Die Längenbegrenzung wird allerdings nur in Bezug auf den explizit angegebenen Namen enforced. D.h. man kann den Dateinamen beliebig lang machen, indem man hierzu die Endung der hochgeladenenen Datei entsprechend modifiziert. Außerdem können beliebige Zeichen in der Dateiendung verwendet werden.
  \item E-Mail Adressen von Benutzern können per Brute-Force des Passwort vergessen Dialogs herausgefunden werden. Es werden unterschiedliche Meldungen verwendet wenn man Mail-Adressen die verwendet werden eingbaut und E-Mail Adressen die nicht verewndet werden. Außerdem ist dauert ein Request mit einer validen E-Mail Adresse erheblich länger.
  \item Ein Nutzer kann bei \texttt{Dateiberechtigung} alle Gruppen sehen auch wenn er nicht Mitglied ist. Es ist auch möglich Berechtigungen zu vergeben, sodass Dateien in dieser Gruppe geteilt werden können.
\item Ein Benutzer kann Zugriff auf sein Konto erhalten, bevor ihm das initale Passwort mitgeteilt wurde. Dazu muss er nur die Passwort vergessen Funktion nutzen um sich ein Passwort per Email zusenden zu lassen.
\item Beim Überschreiben einer Datei tritt eine Race-Condition auf: Wird eine einzelne Datei massiv parallel überschrieben, steigt die Quota des Besitzers kontinuiertlich an.
\item Beim Login ist ersichtlich, ob ein Benutzeraccount existiert oder nicht: Loggt man sich N mal falsch für einen existierenden Benutzer ein, wird der entsprechende Account gesperrt und es erscheint eine Fehlermeldung \enquote{Du bist für 4,8 Minuten gesperrt.}. Die gleiche Aktion führt bei einem nicht existierenden Account niemals zu einer derartigen Fehlermeldung, es erscheint ausschließlich die Meldung \enquote{Falscher Benutzername oder Passwort}.
\item Es ist möglich einen CSRF-Angriff durchzuführen, der beliebige Nutzer auslogged, die Chrome verwenden. Hierzu muss einfach von einer anderen Domain aus ein Request auf die Startseite getriggert werden (Bsp: https://jsfiddle.net/4j3k9ngt/). Das Cookie vom Nutzer wird so zurückgesetzt, bzw. das "username" Feld gelöscht.
\item Dadurch, dass es möglich ist, die Admin- bzw. Alle-Gruppe zu löschen kann ein anderer Admin die Anwendung übernehmen: Er kann die Gruppen Alle und Admin löschen und danach als eigene Gruppen anlegen. Er wird so zum alleinigen Admin der Anwendung. Der Nutzer \enquote{admin} ist danach nur noch ein normaler Nutzer ohne Privilegien. In diesem Zustand kann er auch vollständig über das Admin-Panel gelöscht werden.
\item Es ist möglich die E-Mail Adressen aller Nutzer zu extrahieren: Man legt eine Gruppe an und fügt alle Nutzer dieser Gruppe hinzu (diese kann man aus der Gruppe \enquote{Alle} extrahieren). Im HTML-Code der Gruppenseite sieht man als Gruppenowner die entsprechenden E-Mail Adressen. Sie sind mit den entsprechenden \enquote{Aus der Gruppe entfernen} Buttons verknüpft bzw. werden in der korrospondierenden Form als ID verwendet.
\item Beim Löschen eines Nutzers, der Besitzer einer Gruppe ist, wird eine Löschoperation unter seinen Berechtigungen gestartet. Dadurch wird im Log persistiert, dass der gelöschte Nutzer die Gruppe gelöscht hat, bevor dieser von einem Administrator gelöscht wird. Das ist ein Mangel im Bezug auf die Accountability, da nun das Log Ausgaben enthält, welche nicht stattgefunden haben.
\end{enumerate}

\chapter{Ungewöhnliche Handhabung}

\begin{enumerate}
  \item Werfen und Fangen von Exceptions wie NullPointerException sowie IndexOutOfBoundsException
  \item Single-Sign-On meldet erst Applikation beim Netzdienst mit den Nutzeranmeldedaten an und gibt diese dann an den Nutzer weiter
  \item Der Key mit welchem die Datenbankinhalte verschlüsselt werden liegt in der Konfigurationsdatei verschlüsselt vor. Um diesen zu entschüsseln wird ein Hardcoded Passwort verwendet. Im Code darüber befindet sich ein Kommentar noch ein TODO, das dass Passwort im Live Mode bei Anwendungsstart mit angegeben werden sollte. Abgesehen davon das die Verwendung von Hardcoded Credentials schlecht ist, wird dieser Key ebenfalls für die Play Session Cookies im Klartext verwendet. Somit macht diese Lösung hier keinerlei Sinn.
  \item Die Anwendung findet Dateien auf die der aktuelle Benutzer Zugriff hat, indem *alle* Dateien aus der Datenbank geladen werden, die nicht dem Benutzer gehören. Die Dateien werden folgend lokal gefiltert. Dies ist maximal ineffizient.
  \item Die Anwendung extrahiert die Dateiendung von der ausgewählten Datei und speichert diese ungeprüft und unverändert in dem korrospondierenden Datenbankeintrag. Wird die entsprechende Datei heruntergeladen, erstellt die Anwendung einen Dateinamen bestehend aus dem vom Nutzer angebenen Namen und der extrahierten Endung. Dieser Name wird im Content-Disposition Header der Anwendung ungefiltert zurückgegeben. Hypotetisch wäre hier ein HTTP-Response-Splitting-Angriff möglich, faktisch jedoch leider nicht - Play wirft eine Exception bei Newlines im Header-Value.
  \item Die Anwendung versucht zu verhindern, dass man bei Dateien Permissions verändert, die auf einen selbst bezogen sind. Der Check wurde jedoch gänzlich fehlerhaft implementiert. Ausgehend von einer String-Liste mit Benutzer-Ids prüft die Anwendung ob jede String-Id \enquote{equals} einem User-Objekt (dem Owner der File) ist (z.B. FileService.java, Zeile 309). Dieser Check schlägt immer fehl. Folglich ist es problemlos möglich, die auf den Datei-Owner bezogenen Permissions zu löschen. Dies hat allerdings keine Auswirkungen: Die Methoden hasReadAccess und hasWriteAccess (Authorization.java) gewähren dem Owner einer Datei immer die Authorisierung - unabhängig von den gesetzten Permissions.
  \item Versucht der Anwender eine Gruppenberechtigung zu entfernen, lädt die Anwendung das entsprechende Datei-Objekt aus der Datenbank. Dieses Dateiobjekt verfügt über eine Liste von Gruppen, die Lese- bzw. Schreib-Rechte haben. In einem zweiten Schritt wird das entsprechende Gruppenobjekt anhand des Gruppennamens aus der Datenbank geladen. Die Anwendung ruft die remove Methode der Liste in Verbindung mit dem Gruppenobjekt auf um die Berechtigung zu entfernen. Die remove Methode selbst verwendet hierzu die equals Methoden ihrer Items und die entsprechenden indentifizieren zu können. In der Anwendung selbst wurde die equals Methode für die Gruppen-Klasse nicht überschrieben, d.h. es wird die Standard equals Methode der Java Basisklasse Object verwendet. Diese Methode prüft lediglich, ob die Speicheraddressen der beiden Objekte identisch sind. Hypotetisch müsste die so implementierte Funktionalität fehlschlagen, da die entsprechenden Gruppenobjekte individuell erzeugt wurden. Faktisch verhindert dies leider der L2-Cache\footnote{https://ebean.io/docs/features/l2cache/} von Ebean; dieser bewirkt im Ergebnis, dass bei zwei Queries auf den selben Datensatz nur ein Java-Objekt erzeugt wird.
  	\item Die HTTP Statuscodes werden inkonsistente verwendet. An einigen Stellen wird 200 (ok) an den Client gesendet, obwohl eigentlich ein Fehler passiert ist. Beipiele dafür sind die \texttt{login} und \texttt{changePassword} Methoden in \texttt{UserController}.
  
\end{enumerate}

\printbibliography

% Can be used to add a list of acronyms with their description
%\glsaddall
%\deftranslation{to=German}{Acronyms}{Abkürzungsverzeichnis}
%\deftranslation{to=German}{Glossary}{Glossar}
\printacronyms[title=Abkürzungsverzeichnis,toctitle=Abkürzungsverzeichnis]
\printglossary[title=Glossar,toctitle=Glossar,type=main]

%\addcontentsline{toc}{chapter}{\listfigurename}
% Insert list of figures, if a figure has been added to document
\iftotalfigures
  \listoffigures
\fi

%s\addcontentsline{toc}{chapter}{\listtablename}
% \listoftables       % Tabellenverzeichnis

\begin{appendices}

\KOMAoption{headsepline}{false}

\chapter{Quota Race Condition Exploit Script}
\label{quotarace}
\includepdf{./resources/enemyQuotaRaceCondition_1.pdf}
\includepdf{./resources/enemyQuotaRaceCondition_2.pdf}

\chapter{Fehler beim Anlegen eines neuen Nutzers in der bereitgestellten VM}

\begin{figure}[!htb]
  \centering
    \frame{\includegraphics[width=0.8\paperwidth]{resources/createuser_fail_1.png}}
    \label{createuser_fail_1}
    \caption{Anlegen eines Nutzers in der bereitgestellten VM: Verwendete Daten}
\end{figure}

\begin{figure}[!htb]
  \centering
    \frame{\includegraphics[width=0.8\paperwidth]{resources/createuser_fail_2.png}}
    \label{createuser_fail_2}
    \caption{Anlegen eines Nutzers in der bereitgestellten VM: Daraus resultierender Fehler}
\end{figure}

\chapter{Fehler beim Hochladen einer neuen Datei in der bereitgestellten VM}

\begin{figure}[!htb]
  \centering
    \frame{\includegraphics[width=0.8\paperwidth]{resources/upload_fail_1.png}}
    \label{upload_fail_2}
    \caption{Hochladen einer neuen Datei in der bereitgestellten VM: Verwendete Daten}
  \end{figure}

\begin{figure}[!htb]
  \centering
    \frame{\includegraphics[width=0.8\paperwidth]{resources/upload_fail_2.png}}
    \label{upload_fail_1}
    \caption{Hochladen einer neuen Datei in der bereitgestellten VM: Daraus resultierender Fehler}
  \end{figure}

\end{appendices}

\end{document}
